[{"title":"使用python抓取汽车之家车型数据","date":"2017-11-08T10:05:17.000Z","path":"2017/11/08/使用python抓取汽车之家车型数据/","text":"Talk is cheap, show you my code !123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113import requestsimport pymysqlHOSTNAME = '127.0.0.1'USERNAME = 'root'PASSWORD = 'zyndev'DATABASE = 'zyndev_new'brand = 'http://www.autohome.com.cn/ashx/AjaxIndexCarFind.ashx?type=1'series = 'http://www.autohome.com.cn/ashx/AjaxIndexCarFind.ashx?type=3&amp;value=&#123;&#125;'model = 'http://www.autohome.com.cn/ashx/AjaxIndexCarFind.ashx?type=5&amp;value=&#123;&#125;'def obtain_brand_info(): request_brand = requests.get(brand) if request_brand.status_code == 200: request_brand.close() brand_json = request_brand.json() if brand_json['returncode'] == 0: # 成功 brand_list = brand_json['result']['branditems'] conn = pymysql.connect(HOSTNAME, USERNAME, PASSWORD, DATABASE, charset=\"utf8\") cur = conn.cursor() args = [] for item in brand_list: # 存入数据库 将 dict 转为 list sub_arg = (item['id'], item['name'], item['bfirstletter']) args.append(sub_arg) print(args) # rowcount = cur.executemany('INSERT INTO auto_home_car_brand(brandid,name,bfirstletter) values(%s,%s,%s)', args) # conn.commit() # print(f\"插入品牌:\\n共&#123;len(brand_dict)&#125;\\n成功插入&#123;rowcount&#125;条记录\\n插入失败&#123;len(brand_dict) - rowcount&#125;条\") # cur.close() # conn.close() return brand_list else: raise Exception(\"请求失败\")def obtain_series(brand_list): for brand_info in brand_list: request_series = requests.get(series.format(brand_info['id'])) if request_series.status_code == 200: request_series.close() series_json = request_series.json() if series_json['returncode'] == 0: # 成功 factory_list = series_json['result']['factoryitems'] conn = pymysql.connect(HOSTNAME, USERNAME, PASSWORD, DATABASE, charset=\"utf8\") cur = conn.cursor() args = [] series_count = 0 for factory_item in factory_list: factory_id = factory_item['id'] factory_name = factory_item['name'] series_items = factory_item['seriesitems'] for series_item in series_items: series_count = series_count + 1 sub_arg = (brand_info['id'], factory_id, factory_name, series_item['id'], series_item['name'], series_item['seriesstate'], series_item['seriesorder']) args.append(sub_arg) rowcount = cur.executemany('''INSERT INTO auto_home_car_series(brand_id, factory_id, `factory_name`, `series_id`, `series_name`, `series_state`,`series_order`) values(%s, %s, %s, %s, %s, %s, %s)''',args) conn.commit() print(f\"插入车系:\\n共&#123;series_count&#125;\\n成功插入&#123;rowcount&#125;条记录\\n插入失败&#123;series_count - rowcount&#125;条\") cur.close() conn.close()def obtain_model(): conn = pymysql.connect(HOSTNAME, USERNAME, PASSWORD, DATABASE, charset=\"utf8\") cur = conn.cursor() cur.execute(\"select series_id from auto_home_car_series\") series_list = cur.fetchall() for series in series_list: request_model = requests.get(model.format(series[0])) if request_model.status_code == 200: model_json = request_model.json() request_model.close() if model_json['returncode'] == 0: # 成功 year_items = model_json['result']['yearitems'] conn = pymysql.connect(HOSTNAME, USERNAME, PASSWORD, DATABASE, charset=\"utf8\") cur = conn.cursor() args = [] model_count = 0 for year_item in year_items: for spec_item in year_item['specitems']: model_count = model_count + 1 sub_args = (series[0], year_item['id'], year_item['name'], spec_item['id'], spec_item['name'], spec_item['state'], spec_item['minprice'], spec_item['maxprice']) args.append(sub_args) rowcount = cur.executemany('''INSERT INTO auto_home_car_model( `series_id`, `year_id`, `year_name`, `model_id`, `model_name`, `model_state`, `min_price`, `max_price`) values(%s, %s, %s, %s, %s, %s, %s, %s)''', args) conn.commit() print(f\"插入车型:\\n共&#123;model_count&#125;\\n成功插入&#123;rowcount&#125;条记录\\n插入失败&#123;model_count - rowcount&#125;条\") cur.close() conn.close()def main(): #brand_list = obtain_brand_info() #obtain_series(brand_list) obtain_model()if '__main__' == __name__: main()","tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://feynmanloo.github.io/tags/爬虫/"},{"name":"汽车之家","slug":"汽车之家","permalink":"http://feynmanloo.github.io/tags/汽车之家/"}]},{"title":"软件版本命名规范","date":"2017-09-30T04:05:17.000Z","path":"2017/09/30/软件版本命名规范/","text":"一个正规的软件产品少不了要有规范的命名，一个好的软件产品一定要有个规范的版本号，而在命名版本号时有一些约定俗成的规则，下面我来简单介绍下。 版本命名规范软件版本号有四部分组成，第一部分为主版本号，第二部分为次版本号，第三部分为修订版本号，第四部分为日期版本号加希腊字母版本号，希腊字母版本号共有五种，分别为base、alpha、beta 、RC 、 release 软件版本阶段说明 Base：此版本表示该软件仅仅是一个假页面链接，通常包括所有的功能和页面布局，但是页面中的功能都没有做完整的实现，只是做为整体网站的一个基础架构。 Alpha ：软件的初级版本，表示该软件在此阶段以实现软件功能为主，通常只在软件开发者内部交流，一般而言，该版本软件的Bug较多，需要继续修改，是测试版本。测试 人员提交Bug经开发人员修改确认之后，发布到测试网址让测试人员测试，此时可将软件版本标注为alpha版。 Beta ：该版本相对于Alpha 版已经有了很大的进步，消除了严重错误，但还需要经过多次测试来进一步消除，此版本主要的修改对象是软件的UI。修改的的Bug 经测试人员测试确认后可发布到外网上，此时可将软件版本标注为 beta版。RC ：该版本已经相当成熟了，基本上不存在导致错误的Bug，与即将发行的正式版本相差 无几。Release：该版本意味“最终版本”，在前面版本的一系列测试版之后，终归会有一个正式的版本，是最终交付用户使用的一个版本。该版本有时也称标准版。 版本号修改规则 主版本号：当功能模块有较大的变动，比如增加模块或是整体架构发生变化。此版本号由项目决定是否修改。 次版本号：相对于主版本号而言，次版本号的升级对应的只是局部的变动，但该局部的变动造成程序和以前版本不能兼容，或者对该程序以前的协作关系产生了破坏，或者 是功能上有大的改进或增强。此版本号由项目决定是否修改。 修订版本号：一般是Bug 的修复或是一些小的变动或是一些功能的扩充，要经常发布修订版，修复一个严重 Bug 即可发布一个修订版。此版本号由项目经理 决定是否修改。 日期版本号：用于记录修改项目的当前日期，每天对项目的修改都需要更改日期版本 号。此版本号由开发人员决定是否修改。 希腊字母版本号：此版本号用于标注当前版本的软件处于哪个开发阶段，当软件进入 到另一个阶段时需要修改此版本号。此版本号由项目决定是否修改。 版本发布周期非紧急情况：首先由测试人员测试并提交Bug，其次开发人员会尽量在当天修复Bug并在第二天发布该版本的alpha版，然后由测试人员测试验证关闭Bug之后在第三天会发布该版本的 beta 版。 紧急情况：如果Bug比较紧急可跳过一般流程，由开发人员尽快修复Bug，测试确认之后直接发布该版本的 beta版。 版本号修改举例说明如此时版本号为：1.0.0.0321_alpha ，此时为内部测试阶段 开发人员修复了测试人员提交的bug并经测试人员测试验证关闭bug之后，发布到外网时，此时就进入了软件的下一个阶段，版本号可改为：1.0.0.0321_beta ，如当前日期跟上一个版本号的日期不一样，版本号可改为：1.0.0.0322_beta。 如果修复了一些重大Bug 并按照流程发布到外网时就可发布一个修订版，如1.0.1.0322_beta，日期为发布的当前日期。 如果对软件进行了一些功能上的改进或增强，进行了一些局部变动的时候要修改次版本号，如：1.1.0.0322_beta（上一级有变动时，下级要归零）。 当功能模块有较大变动，增加模块或整体架构发生变化时要修改主版本号，如新增加了退款功能，则版本号要改为：2.0.0.0322_beta 。 英文原文：https://jingyan.baidu.com/article/8cdccae9659f5c315413cde6.html","tags":[{"name":"版本号","slug":"版本号","permalink":"http://feynmanloo.github.io/tags/版本号/"},{"name":"规范","slug":"规范","permalink":"http://feynmanloo.github.io/tags/规范/"}]},{"title":"开源许可证GPL、BSD、MIT、Mozilla、Apache和LGPL的区别","date":"2017-09-18T04:05:17.000Z","path":"2017/09/18/开源许可证GPL、BSD、MIT、Mozilla、Apache和LGPL的区别/","text":"首先借用有心人士的一张相当直观清晰的图来划分各种协议：开源许可证GPL、BSD、MIT、Mozilla、Apache和LGPL的区别 image 以下是上述协议的简单介绍： BSD开源协议BSD开源协议是一个给于使用者很大自由的协议。基本上使用者可以”为所欲为”,可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。 但”为所欲为”的前提当你发布使用了BSD协议的代码，或则以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件： 如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。 如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。 不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。 BSD 代码鼓励代码共享，但需要尊重代码作者的著作权。BSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销售，因此是对商业集成很友好的协议。而很多的公司企业在选用开源产品的时候都首选BSD协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者二次开发。 Apache Licence 2.0Apache Licence是著名的非盈利开源组织Apache采用的协议。该协议和BSD类似，同样鼓励代码共享和尊重原作者的著作权，同样允许代码修改，再发布（作为开源或商业软件）。需要满足的条件也和BSD类似： 需要给代码的用户一份Apache Licence 如果你修改了代码，需要再被修改的文件中说明。 在延伸的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明。 如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。你可以在Notice中增加自己的许可，但不可以表现为对Apache Licence构成更改。 Apache Licence也是对商业应用友好的许可。使用者也可以在需要的时候修改代码来满足需要并作为开源或商业产品发布/销售。 GPL我们很熟悉的Linux就是采用了GPL。GPL协议和BSD, Apache Licence等鼓励代码重用的许可很不一样。GPL的出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但不允许修改后和衍生的代码做为闭源的商业软件发布和销售。这也就是为什么我们能用免费的各种linux，包括商业公司的linux和linux上各种各样的由个人，组织，以及商业软件公司开发的免费软件了。 GPL协议的主要内容是只要在一个软件中使用(”使用”指类库引用，修改后的代码或者衍生代码)GPL 协议的产品，则该软件产品必须也采用GPL协议，既必须也是开源和免费。这就是所谓的”传染性”。GPL协议的产品作为一个单独的产品使用没有任何问题，还可以享受免费的优势。 由于GPL严格要求使用了GPL类库的软件产品必须使用GPL协议，对于使用GPL协议的开源代码，商业软件或者对代码有保密要求的部门就不适合集成/采用作为类库和二次开发的基础。 其它细节如再发布的时候需要伴随GPL协议等和BSD/Apache等类似。 LGPLLGPL是GPL的一个为主要为类库使用设计的开源协议。和GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议不同。LGPL 允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并发布和销售。 但是如果修改LGPL协议的代码或者衍生，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议。因此LGPL协议的开源代码很适合作为第三方类库被商业软件引用，但不适合希望以LGPL协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。 GPL/LGPL都保障原作者的知识产权，避免有人利用开源代码复制并开发类似的产品 MITMIT是和BSD一样宽范的许可协议,作者只想保留版权,而无任何其他了限制.也就是说,你必须在你的发行版里包含原许可协议的声明,无论你是以二进制发布的还是以源代码发布的. MPLMPL是The Mozilla Public License的简写，是1998年初Netscape的 Mozilla小组为其开源软件项目设计的软件许可证。MPL许可证出现的最重要原因就是，Netscape公司认为GPL许可证没有很好地平衡开发者对源代码的需求和他们利用源代码获得的利益。同著名的GPL许可证和BSD许可证相比，MPL在许多权利与义务的约定方面与它们相同（因为都是符合OSIA 认定的开源软件许可证）。但是，相比而言MPL还有以下几个显著的不同之处: PL虽然要求对于经MPL许可证发布的源代码的修改也要以MPL许可证的方式再许可出来，以保证其他人可以在MPL的条款下共享源代码。但是，在MPL 许可证中对“发布”的定义是“以源代码方式发布的文件”，这就意味着MPL允许一个企业在自己已有的源代码库上加一个接口，除了接口程序的源代码以MPL 许可证的形式对外许可外，源代码库中的源代码就可以不用MPL许可证的方式强制对外许可。这些，就为借鉴别人的源代码用做自己商业软件开发的行为留了一个豁口。 PL许可证第三条第7款中允许被许可人将经过MPL许可证获得的源代码同自己其他类型的代码混合得到自己的软件程序。 对软件专利的态度，MPL许可证不像GPL许可证那样明确表示反对软件专利，但是却明确要求源代码的提供者不能提供已经受专利保护的源代码（除非他本人是专利权人，并书面向公众免费许可这些源代码），也不能在将这些源代码以开放源代码许可证形式许可后再去申请与这些源代码有关的专利。 对源代码的定义而在MPL（1.1版本）许可证中，对源代码的定义是:“源代码指的是对作品进行修改最优先择取的形式，它包括:所有模块的所有源程序，加上有关的接口的定义，加上控制可执行作品的安装和编译的‘原本’（原文为‘Script’），或者不是与初始源代码显著不同的源代码就是被源代码贡献者选择的从公共领域可以得到的程序代码。” PL许可证第3条有专门的一款是关于对源代码修改进行描述的规定，就是要求所有再发布者都得有一个专门的文件就对源代码程序修改的时间和修改的方式有描述。 英文原文：http://www.mozilla.org/MPL/MPL-1.1.html","tags":[{"name":"开源许可证","slug":"开源许可证","permalink":"http://feynmanloo.github.io/tags/开源许可证/"}]},{"title":"树莓派+SSH反向连接=无公网IP也能访问本地PI","date":"2017-09-03T11:37:17.000Z","path":"2017/09/03/树莓派-SSH反向连接-无公网IP也能访问本地PI/","text":"SSH简介接触Linux恐怕对SSH再熟悉不过了，还有scp，sftp各种方便的功能，一般的使用都需要ip:port（如果不是默认22的话），但有些情况比较特殊，就是想连接一台内网主机（比如公司内网，当然你肯定做不了Port Forwarding，除非你想在公司防火墙上拆个洞）。稍懂一点网络的童鞋会明白，Internet上去主动连接一台内网是不可能的，一般的解决方案分两种，一种是端口映射（Port Forwarding），将内网主机的某个端口Open出防火墙，相当于两个外网主机通信；另一种是内网主机主动连接到外网主机，又被称作反向连接（Reverse Connection），这样NAT路由/防火墙就会在内网主机和外网主机之间建立映射，自然可以相互通信了。但是，这种映射是NAT路由自动维持的，不会持续下去，如果连接断开或者网络不稳定都会导致通信失败，这时内网主机需要再次主动连接到外网主机，建立连接。 理论的介绍完了，下面实际操作：A要控制B A主机：外网，ip：123.123.123.123，sshd端口：2221 B主机：内网，sshd端口：2223 无论是外网主机A，还是内网主机B都需要跑ssh daemon 首先在B上执行1$ ssh -NfR 1234:localhost:2223 user1@123.123.123.123 -p2221 这句话的意思是将A主机的1234端口和B主机的2223端口绑定，相当于远程端口映射（Remote Port Forwarding）。 这里每次需要输入A主机user1的登陆密码，后面会讲到解决办法。 这时在A主机上sshd会listen本地1234端口 1234$ ss -antState Recv-Q Send-Q Local Address:Port Peer Address:PortLISTEN 0 128 127.0.0.1:1234 *:* 像平时一样连接到A主机的1234端口就可以控制内网B主机了 1$ ssh localhost -p1234 解决SSH连接不稳定的问题 一开始提到，这种反向连接（Reverse Connection）不稳定，可能随时断开，需要内网主机B再次向外网A发起连接，这时需要个“朋友”帮你在内网B主机执行这条命令。它就是Autossh。在此之前还要解决之前的一个问题，那就是每次内网主机B连接外网主机A时都需要输入密码，这个问题ssh本身是提供另外一种验证方式——通过密钥验证用户身份，实现自动登录。 在内网B主机上生产公钥和私钥 1234$ ssh-keygen...(一直按Enter，最后在~/.ssh/下生成密钥)$ ls ~/.ssh/id_rsa id_rsa.pub known_hosts 复制B主机上生成的id_rsa.pub公钥到外网A主机上，并将内容加入到~/.ssh/authorized_keys中 1$ cat id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys 试下，内网B主机连接外网A主机，就不再输入密码验证了 补充：今天了解到ssh-copy-id这个命令，上面这个操作就变的简单了1$ ssh-copy-id user1@123.123.123.123 再来看看Autossh的用法1$ autossh -M 5678 -NR 1234:localhost:2223 user1@123.123.123.123 -p2221 比之前的命令添加的一个-M 5678参数，负责通过5678端口监视连接状态，连接有问题时就会自动重连，去掉了一个-f参数，因为autossh本身就会在background运行。 终极方案：当重启内网B主机，谁来自动Autossh呢，加入daemon吧以daemon方式执行，相当于root去执行autossh, ssh，这时刚才普通用户目录下的.ssh/authorized_keys文件会不起效。有两种办法解决，一种是用autossh的参数指定.ssh路径；另外一种是以普通用户身份执行daemon，下面是第二种方式。1/bin/su -c '/usr/bin/autossh -M 5678 -NR 1234:localhost:2223 user1@123.123.123.123 -p2221' - user1 autossh还有很多参数，用来设置重连间隔等等。 将上面命令放入下面各启动方式中，根据自己系统自己配置： SysV：/etc/inid.d/autossh Upstart: /etc/init/autossh.conf systemd: /usr/lib/systemd/system/autossh.service P.S.1.家里是ADSL的话，用DDNS，解决ip问题 2.外网有路由的可设下端口映射 3.虽然有密钥和密码保护，但还请小心使用","tags":[{"name":"树莓派","slug":"树莓派","permalink":"http://feynmanloo.github.io/tags/树莓派/"},{"name":"SSH","slug":"SSH","permalink":"http://feynmanloo.github.io/tags/SSH/"},{"name":"autossh","slug":"autossh","permalink":"http://feynmanloo.github.io/tags/autossh/"}]},{"title":"树莓派+win10iot跑NetCore2网站","date":"2017-08-29T02:06:02.000Z","path":"2017/08/29/树莓派+win10iot跑NetCore2网站/","text":"前期准备 一个树莓派刷上最新的Win10 iot 15063系统 一个NetCore2的网站，能在PC上正常运行就可以了 网站发布运行指令1dotnet publish -c release -r win-arm image 然后把红线部分的内容复制到树莓派上 这里可以通过文件共享复制1\\\\192.168.99.147\\c$\\ PS:192.168.99.147是我树莓派的ip 然后登录到树莓派的PowerShell(可通过 Iot Dashboard 上的 我的设备 右键 找到) 运行指令，开放防火墙端口1netsh advfirewall firewall add rule name=\"NetCore2 APP\" dir=in action=allow protocol=TCP localport=5001 默认端口是5000，我这里项目中修改成5001 然后运行12cd C:\\Web.\\WeChat.exe WeChat是我的项目名，需要自行替换成自己的 最终效果 image","tags":[{"name":"树莓派","slug":"树莓派","permalink":"http://feynmanloo.github.io/tags/树莓派/"},{"name":"Win10 iot","slug":"Win10-iot","permalink":"http://feynmanloo.github.io/tags/Win10-iot/"},{"name":"NetCore2","slug":"NetCore2","permalink":"http://feynmanloo.github.io/tags/NetCore2/"},{"name":"网站","slug":"网站","permalink":"http://feynmanloo.github.io/tags/网站/"}]},{"title":"Hello World","date":"2017-08-28T02:06:02.000Z","path":"2017/08/28/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]